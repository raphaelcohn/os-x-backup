#!/usr/bin/env sh
# This file is part of os-x-backup. It is subject to the license terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/raphaelcohn/os-x-backup/master/COPYRIGHT. No part of os-x-backup, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
# Copyright Â© 2021 The developers of os-x-backup. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/raphaelcohn/os-x-backup/master/COPYRIGHT.


set -e
set -u
set -f

_program_path_find()
{
	if [ "${0%/*}" = "$0" ]; then

		# We've been invoked by the interpreter as, say, bash program
		if [ -r "$0" ]; then
			pwd -P
		# Clutching at straws; probably run via a download, anonymous script, etc, weird execve, etc
		else
			printf '\n'
		fi

	else

		# We've been invoked with a relative or absolute path (also when invoked via PATH in a shell)

		_program_path_find_parentPath()
		{
			parentPath="${scriptPath%/*}"
			if [ -z "$parentPath" ]; then
				parentPath='/'
			fi
			cd "$parentPath" 1>/dev/null
		}

		# pdksh / mksh have problems with unsetting a variable that was never set...
		if [ "${CDPATH+set}" = 'set' ]; then
			unset CDPATH
		fi

		if command -v realpath 1>/dev/null 2>/dev/null; then
			(
				scriptPath="$(realpath "$0")"

				_program_path_find_parentPath
				pwd -P
			)
		elif command -v readlink 1>/dev/null 2>/dev/null; then
			(
				local recursionDepth=0
				_program_path_resolve_symlinks_recursively()
				{
					local unresolvedPath="$1"
					
					recursionDepth=$((recursionDepth + 1))
					
					if [ $recursionDepth -gt 10 ]; then
						printf '%s\n' 'Recursion to depths greater than 10 is not allowed when resolving links.'
						return 1
					fi
					
					local potentialLinkDestination="$(readlink -- "$unresolvedPath")"
					
					if [ -z "$potentialLinkDestination" ]; then
						scriptPath="$unresolvedPath"
						return 0
					fi
					local linkDestination="$potentialLinkDestination"
					local parentFolderPath="${unresolvedPath%/*}"
					
					if [ "$parentFolderPath" = "$unresolvedPath" ]; then
						_program_path_resolve_symlinks_recursively "$linkDestination"
					else
						case "$linkDestination" in
														
							/*)
								_program_path_resolve_symlinks_recursively "$linkDestination"
							;;
							
							*)
								_program_path_resolve_symlinks_recursively "$parentFolderPath"/"$linkDestination"
							;;
							
						esac
					fi
				}

				scriptPath="$0"
				_program_path_resolve_symlinks_recursively "$scriptPath"

				_program_path_find_parentPath
				pwd -P
			)
		else
			# This approach will fail in corner cases where the script itself is a symlink in a path not parallel with the concrete script
			(
				scriptPath="$0"

				_program_path_find_parentPath
				pwd -P
			)
		fi

	fi
}

cd "$(_program_path_find)" 1>/dev/null 2>/dev/null

_program_name='os-x-backup'

. functions/common.sh
. functions/apfs.sh
. functions/apfs-snapshot.sh
. functions/rclone.sh
. functions/remote-backup.sh
. functions/rsync.sh
. functions/time-machine.sh

set_mount_point_folder_path()
{
	local time_machine_snapshot_date="$1"
	local our_mount_name="$2"
	
	local snapshot_name="$(time_machine_snapshot_date_to_name "$time_machine_snapshot_date")"
	mount_point_folder_path="$our_snapshot_mounts_folder_path"/"$our_mount_name"
}

depends mkdir
make_our_backup_folder()
{
	our_backup_folder_path="$TMPDIR"/backup
	mkdir -m 0700 -p "$our_backup_folder_path"
}

depends rmdir
remove_our_backup_folder()
{
	rmdir "$our_backup_folder_path"
	our_backup_folder_path=''
}

depends mkdir
make_our_snapshot_mounts_folder()
{
	our_snapshot_mounts_folder_path="$TMPDIR"/snapshot-mounts
	mkdir -m 0700 -p "$our_snapshot_mounts_folder_path"
}

depends rmdir
remove_our_snapshot_mounts_folder()
{
	rmdir "$our_snapshot_mounts_folder_path"
	our_snapshot_mounts_folder_path=''
}

mount_time_machine_snapshot()
{
	set_mount_point_folder_path "$time_machine_snapshot_date" "$our_mount_name"
	
	local snapshot_name="$(time_machine_snapshot_date_to_name "$time_machine_snapshot_date")"
	mount_apfs_snapshot "$snapshot_name" "$volumeDevice" "$mount_point_folder_path"
}

unmount_time_machine_snapshot()
{
	unmount_apfs_snapshot_forcibly "$mount_point_folder_path"
	rmdir "$mount_point_folder_path"
}

depends rmdir
use_time_machine_snapshot()
{
	local time_machine_snapshot_date="$1"
	local volumeDevice="$2"
	local our_mount_name="$3"
	local callback="$4"
	shift 4

	mount_point_folder_path=''
	mount_time_machine_snapshot
		
		$callback "$@"
	
	unmount_time_machine_snapshot
	mount_point_folder_path=''
}

ensure_mounts_and_snapshots_cleaned_up()
{
	if [ -n "$time_machine_snapshot_date" ]; then
		
		if [ -n "$mount_point_folder_path" ]; then
			set +e
				unmount_time_machine_snapshot
				mount_point_folder_path=''
			set -e
		fi

		set +e
			delete_time_machine_snapshot "$time_machine_snapshot_date"
			time_machine_snapshot_date=''
		set -e
	fi
	
	remove_temporary_directory
}

take_and_use_time_machine_snapshot()
{
	local volumeDevice="$1"
	local our_mount_name="$2"
	local callback="$3"
	shift 3

	trap ensure_mounts_and_snapshots_cleaned_up EXIT
	time_machine_snapshot_date=''
	take_time_machine_snapshot
	
		use_time_machine_snapshot "$time_machine_snapshot_date" "$volumeDevice" "$our_mount_name" "$callback" "$our_mount_name" "$@"
		
	delete_time_machine_snapshot "$time_machine_snapshot_date"
	time_machine_snapshot_date=''
	trap remove_temporary_directory EXIT
}

depends tr rm
iterate_over_time_machine_volumes()
{
	local callback="$1"
	shift 1
	
	local apfs_mounts_file_path="$TMPDIR"/apfs_mounts
	find_apfs_mounts >"$apfs_mounts_file_path"
	
	local device_path
	local volumeDevice
	while IFS=' ' read -r device_path volumeDevice
	do
		local is_excluded
		time_machine_is_volume_excluded "$volumeDevice"
		if $is_excluded; then
			printf "Excluding %s\n" "$volumeDevice" 1>&2
			continue
		fi
		
		# Not used.
		local disk_name="${device_path##*/}"
		
		if [ "$volumeDevice" = '/' ]; then
			local our_mount_name='root'
		else
			local volumeDevice_without_leading_slash="${volumeDevice#/}"
			local relative_mount_name="$(printf '%s' "$volumeDevice_without_leading_slash" | tr '/' '_')"
			local our_mount_name="root_${relative_mount_name}"
		fi
		
		$callback "$volumeDevice" "$our_mount_name" "$@"
	done <"$apfs_mounts_file_path"
	
	rm "$apfs_mounts_file_path"
}

make_and_use_snapshots()
{
	local callback="$1"
	shift 1
	
	local our_snapshot_mounts_folder_path
	make_our_snapshot_mounts_folder

		iterate_over_time_machine_volumes take_and_use_time_machine_snapshot $callback "$@"

	remove_our_snapshot_mounts_folder
}

depends find awk rm
make_backup_of_mount()
{
	local our_mount_name="$1"
	local remote="$2"
	local use_rsync="$3"
	local backup_kind="$4"
	
	printf "Using snapshot for %s as %s\n" "$volumeDevice" "$our_mount_name" 1>&2
	
	local our_mount_name_configuration_path
	set_our_mount_name_configuration_path "$our_mount_name"
	
	local is_usable
	folder_is_usable "$our_mount_name_configuration_path"
	if ! $is_usable; then
		printf 'No configuration for mount %s at %s\n' "$our_mount_name" "$our_mount_name_configuration_path"
		return 0
	fi
	
	# Rather than trying to filter an entire root file system (eg /), this divides it up into interesting folders (eg /Users/raph) and only syncs them.
	local folder_paths_file="$TMPDIR"/folder_paths
	cd "$our_mount_name_configuration_path" 1>/dev/null 2>/dev/null
		# Modified from https://superuser.com/questions/195879/using-find-to-list-only-directories-with-no-more-childs
		{
			find . -type d
			printf '\n'
		} | awk 'index($0,prev"/")!=1 && NR!=1 {print prev} 1 {sub(/\/$/,""); prev=$0}' >"$folder_paths_file"
	cd - 1>/dev/null 2>/dev/null
	
	# Expand backup_kind to a callback with arguments (a sort of a closure).
	case "$backup_kind" in
		
		full)
			set -- rclone_or_rsync_full_back_up "$our_mount_name" "$mount_point_folder_path"
		;;
		
		replaced)
			set -- rclone_or_rsync_replaced_back_up "$our_mount_name" "$mount_point_folder_path"
		;;
		
		copy_dest|differential)
			set -- rclone_or_rsync_full_then_copy_dest_or_link_dest_or_differential_or_first_incremental_backup "$our_mount_name" "$mount_point_folder_path" "$backup_kind"
		;;
		
		link_dest)
			guard_link_dest_is_use_rsync "$use_rsync"
			set -- rclone_or_rsync_full_then_copy_dest_or_link_dest_or_differential_or_first_incremental_backup "$our_mount_name" "$mount_point_folder_path" 'link_dest'
		;;
	
		incremental)
			exit_configuration_message 'incremental back ups are not yet properly supported'
		;;
	
		*)
			exit_configuration_message "Unknown backup kind $backup_kind"
		;;
		
	esac
	
	local folder_path
	local relative_path_under_mount_to_synchronize
	while IFS= read -r folder_path
	do
		if [ "$folder_path" = '.' ]; then
			relative_path_under_mount_to_synchronize=''
		else
			# strip leading './'
			relative_path_under_mount_to_synchronize="${folder_path#./}"
		fi
		"$@" "$relative_path_under_mount_to_synchronize"
		
	done <"$folder_paths_file"
	
	rm "$folder_paths_file"
}

configure()
{
	local use_rsync='false'
	local backup_kind='copy_dest'
	local remote='remote'
	local remote_path_prefix='backups'
	
	local configuration_file_path="$configuration_folder_path"/configuration.sh
	local is_usable
	folder_is_usable "$configuration_file_path"
	if $is_usable; then
		. "$configuration_file_path" || exit_configuration_message "Could not load configuration at $configuration_file_path"
	fi

	case "$use_rsync" in
		true|false)
			configured_use_rsync="$use_rsync"
		;;
		
		*)
			exit_configuration_message "use_rsync can only be true or false, not $use_rsync"
		;;
	esac
	

	case "$backup_kind" in
		full|replaced|copy_dest|differential|incremental)
			configured_backup_kind="$backup_kind"
		;;
		
		link_dest)
			if ! $use_rsync; then
				exit_configuration_message  "backup_kind can not be 'link_dest' if use_rsync='false'"
			fi
			configured_backup_kind='link_dest'
		;;
		
		*)
			exit_configuration_message "backup_kind can not be '$backup_kind'"
		;;
	esac

	local remote_path_prefix_is_absolute
	if [ "$(first_character "$remote_path_prefix")" = '/' ]; then
		remote_path_prefix_is_absolute=true
	else
		remote_path_prefix_is_absolute=false
	fi
	if [ "$(last_character "$remote_path_prefix")" = '/' ]; then
		exit_configuration_message "remote_path_prefix can not end with a trailing slash '/'"
	fi
	configured_remote_path_prefix="$remote_path_prefix"
	
	case "$(last_character "$remote")" in
		
		':')
			exit_configuration_message "remotes ending with a trailing colon ':' are not supported"
		;;
		
		'/')
			exit_configuration_message "remotes ending with a trailing slash '/' are not supported"
		;;
		
		*)
			:
		;;
		
	esac
	case "$(first_character "$remote")" in
		
		':')
			exit_configuration_message "remotes starting with a leading colon ':' are not supported"
		;;
		
		'')
			if $remote_path_prefix_is_absolute; then
				exit_configuration_message "If remote is empty (remote='') then remote_path_prefix must not be absolute (ie it must not start with a leading slash '/'))"
			fi
			configured_remote="$(pwd)"
			configured_remote_suffix='/'
		;;
		
		'/')
			if $remote_path_prefix_is_absolute; then
				exit_configuration_message "If remote starts with a leading slash (remote='/..') then remote_path_prefix must not be absolute (ie it must not start start with a leading slash '/'))"
			fi
			configured_remote="$remote"
			configured_remote_suffix='/'
		;;
		
		*)
			configured_remote="$remote"
			configured_remote_suffix=':'
		;;
		
	esac
}

set_rclone_or_rsync_environment_file_path()
{
	if $configured_use_rsync; then
		configured_rclone_or_rsync_environment_file_path="$configuration_folder_path"/rsync.environment.sh
	else
		configured_rclone_or_rsync_environment_file_path="$configuration_folder_path"/rclone.environment.sh
	fi
}

depends hostname awk tr
configure_machine_name()
{
	configured_machine_name="$(hostname | awk -F. '{print $1}' | tr '[:upper:]' '[:lower:]')"
}

main()
{
	local configuration_folder_path
	set_configuration_folder_path

	local tools_folder_path="$(pwd)"/tools

	local configured_use_rsync
	local configured_backup_kind
	local remote_path_prefix_is_absolute
	local configured_remote
	local configured_remote_suffix
	local configured_remote_path_prefix
	configure

	local configured_rclone_or_rsync_environment_file_path
	set_rclone_or_rsync_environment_file_path
	
	local configured_password='Hello'
	local configured_salt='Mum'
	
	local temporary_folder_path="$(pwd)"/temporary
	make_temporary_folder
	
	local rclone_temporary_configuration_file_path="$TMPDIR"/rclone.conf
	rclone_refresh_temporary_configuration_file
	
	local configured_obscured_password="$(rclone_obscure_password configured_password)"
	local configured_obscured_salt="$(rclone_obscure_password configured_salt)"
	
	local configured_machine_name
	configure_machine_name
	
	make_our_backup_folder
		
		make_and_use_snapshots make_backup_of_mount "$configured_remote" "$configured_use_rsync" "$configured_backup_kind"
	
	remove_our_backup_folder
	
	# TODO: Store our configuration (except for rclone.conf and the like) on a remote server.
	# TODO: Update our configuration from a remote server.
	
	# TODO: Implement alternate backup-dir approach that renames files and ignores them.
	# TODO: Implement a restore
	# TODO: Implement generation of initial configuration (simple, for me)
	
	# TODO: Ask rsync.net if possible to force snapshots?
	# TODO: Ask rsync.net if size limits include duplicated data? (ie is it deduplicated size, can I force deduplication to run?)
	
	# TODO: rclone --immutable flag
	
}

main "$@"
